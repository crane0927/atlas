# 功能规格说明

## 宪法检查

本规格说明必须符合项目宪法要求：

- ✅ **模块化**: 功能归属 `atlas-common-feature-core` 模块
- ✅ **代码复用**: 提供可复用的公共类和工具
- ✅ **中文注释**: 所有代码使用中文注释
- ✅ **配置文件格式**: 使用 YAML 格式

## 功能描述

实现 `atlas-common-feature-core` 模块，提供项目核心功能特性，包括统一响应包装类（Result<T>）、错误码常量、异常体系、分页对象和基础常量等。该模块是项目的基础设施，为所有业务模块提供统一的响应格式、错误处理和分页支持。

## 功能需求

### FR1: 统一响应包装类 Result<T>

**需求描述**: 提供统一的 API 响应包装类，封装所有 HTTP 接口的响应数据。

**功能要求**:
- 支持泛型，可以包装任意类型的数据
- 包含状态码（code）、消息（message）、数据（data）、时间戳（timestamp）等字段
- 提供成功和失败的静态工厂方法
- 支持链式调用
- 序列化为 JSON 时字段命名符合 RESTful 规范

**验收标准**:
- Result 类可以包装任意类型的数据
- 成功响应包含正确的状态码和数据
- 失败响应包含错误码和错误消息
- 所有字段正确序列化为 JSON
- 提供便捷的静态方法创建成功/失败响应

### FR2: 错误码常量类

**需求描述**: 提供错误码常量类，定义项目通用的错误码。

**功能要求**:
- 定义通用错误码常量（系统错误、参数错误、业务错误、权限错误、数据错误）
- 错误码格式符合项目规范（6位数字：MMTTSS）
- 模块码使用 05（atlas-common-feature）
- 错误码常量类包含中文注释说明
- 提供错误码与错误消息的映射机制

**验收标准**:
- 错误码格式符合 6 位数字规范
- 所有错误码都有对应的常量定义
- 错误码常量类包含完整的中文注释
- 错误码与错误消息可以正确映射

### FR3: 异常体系

**需求描述**: 提供统一的业务异常类体系，支持错误码和错误消息。

**功能要求**:
- 提供基础业务异常类（BusinessException）
- 支持错误码和错误消息
- 支持异常链（cause）
- 提供不同错误类型的异常子类（参数异常、业务异常、权限异常等）
- 异常类包含完整的中文注释

**验收标准**:
- 异常类可以携带错误码和错误消息
- 异常可以正确抛出和捕获
- 异常信息可以正确序列化
- 异常类包含完整的中文注释

### FR4: 分页对象

**需求描述**: 提供统一的分页响应对象，支持分页查询结果封装。

**功能要求**:
- 包含分页信息（当前页、每页大小、总记录数、总页数）
- 包含数据列表
- 支持泛型，可以封装任意类型的数据列表
- 提供便捷的构造方法
- 序列化为 JSON 时字段命名符合 RESTful 规范

**验收标准**:
- 分页对象可以封装任意类型的数据列表
- 分页信息计算正确（总页数、是否有下一页等）
- 所有字段正确序列化为 JSON
- 提供便捷的构造方法

### FR5: 基础常量类

**需求描述**: 提供项目基础常量类，定义常用的常量值。

**功能要求**:
- 定义 HTTP 状态码常量
- 定义常用字符串常量（如空字符串、默认值等）
- 定义常用数字常量
- 常量类包含中文注释说明
- 常量类使用私有构造函数防止实例化

**验收标准**:
- 所有常量都有明确的定义和注释
- 常量类不能被实例化
- 常量值符合项目规范
- 常量类包含完整的中文注释

## 用户场景

### 场景 1: 开发人员使用 Result 包装 API 响应

**角色**: 后端开发人员

**前置条件**: 开发人员正在实现 Controller 接口

**操作流程**:
1. 开发人员在 Controller 方法中调用 Service 方法获取数据
2. 使用 `Result.success(data)` 创建成功响应
3. 返回 Result 对象

**预期结果**: API 返回统一的响应格式，包含状态码、消息和数据

### 场景 2: 开发人员使用错误码和异常

**角色**: 后端开发人员

**前置条件**: 开发人员需要处理业务异常

**操作流程**:
1. 开发人员在 Service 方法中检测业务错误
2. 使用错误码常量创建 BusinessException
3. 抛出异常
4. 全局异常处理器捕获异常并返回错误响应

**预期结果**: 异常被正确捕获，返回包含错误码和错误消息的统一错误响应

### 场景 3: 开发人员使用分页对象

**角色**: 后端开发人员

**前置条件**: 开发人员需要实现分页查询接口

**操作流程**:
1. 开发人员在 Service 方法中执行分页查询
2. 获取总记录数和数据列表
3. 使用 `PageResult.of(list, total)` 创建分页响应
4. 返回 PageResult 对象

**预期结果**: API 返回统一的分页响应格式，包含分页信息和数据列表

### 场景 4: 前端开发人员解析 API 响应

**角色**: 前端开发人员

**前置条件**: 前端需要调用后端 API

**操作流程**:
1. 前端发送 HTTP 请求到后端 API
2. 接收统一的 Result 格式响应
3. 根据状态码判断请求是否成功
4. 提取数据或错误信息

**预期结果**: 前端可以统一处理所有 API 响应，简化错误处理逻辑

## 数据模型

### Result<T>

| 字段名 | 类型 | 说明 | 必填 |
|--------|------|------|------|
| code | String | 状态码（成功为 "000000"，失败为错误码） | 是 |
| message | String | 消息（成功为 "操作成功"，失败为错误消息） | 是 |
| data | T | 响应数据（泛型） | 否 |
| timestamp | Long | 时间戳（毫秒） | 是 |

### PageResult<T>

| 字段名 | 类型 | 说明 | 必填 |
|--------|------|------|------|
| list | List<T> | 数据列表（泛型） | 是 |
| total | Long | 总记录数 | 是 |
| page | Integer | 当前页码（从 1 开始） | 是 |
| size | Integer | 每页大小 | 是 |
| pages | Integer | 总页数 | 是 |

### BusinessException

| 字段名 | 类型 | 说明 | 必填 |
|--------|------|------|------|
| errorCode | String | 错误码（6位数字） | 是 |
| message | String | 错误消息 | 是 |
| cause | Throwable | 异常原因 | 否 |

## 业务逻辑

### Result 创建逻辑

1. **成功响应**: 
   - 状态码为 "000000"
   - 消息为 "操作成功"
   - 包含数据对象
   - 自动设置时间戳

2. **失败响应**:
   - 状态码为具体的错误码
   - 消息为错误消息
   - 数据为 null
   - 自动设置时间戳

### 分页计算逻辑

1. 根据总记录数和每页大小计算总页数：`pages = (total + size - 1) / size`
2. 判断是否有上一页：`page > 1`
3. 判断是否有下一页：`page < pages`

### 异常处理逻辑

1. Service 层抛出 BusinessException
2. 全局异常处理器（@RestControllerAdvice）捕获异常
3. 提取错误码和错误消息
4. 创建 Result 失败响应并返回

## 异常处理

### 异常类型

1. **参数异常（ParameterException）**: 参数校验失败
2. **业务异常（BusinessException）**: 业务逻辑错误
3. **权限异常（PermissionException）**: 权限不足
4. **数据异常（DataException）**: 数据操作错误

### 异常处理策略

- 所有异常都包含错误码和错误消息
- 异常信息可以正确序列化为 JSON
- 全局异常处理器统一处理所有异常

## 测试要求

- 单元测试覆盖率 ≥ 80%
- 测试 Result 类的所有静态方法
- 测试异常类的创建和序列化
- 测试分页对象的计算逻辑
- 测试错误码常量类的正确性

## 成功标准

1. **统一性**: 所有 API 响应使用统一的 Result 格式，响应格式一致性达到 100%
2. **可维护性**: 错误码和异常体系清晰，新错误码添加时间不超过 5 分钟
3. **易用性**: 开发人员可以在 10 分钟内理解并使用 Result 和异常体系
4. **完整性**: 所有功能需求实现完成，单元测试覆盖率 ≥ 80%
5. **规范性**: 所有代码符合项目规范，中文注释覆盖率 100%

## 依赖关系

### 内部依赖

- 依赖父 POM（atlas）的版本管理
- 依赖错误码规范文档的定义

### 外部依赖

- Spring Boot Web（用于序列化支持）
- Lombok（用于简化代码）
- Jackson（用于 JSON 序列化）

## 假设

1. 所有业务模块都会使用 Result 包装响应
2. 错误码格式遵循 6 位数字规范（MMTTSS）
3. 分页查询使用标准的 page 和 size 参数
4. 全局异常处理器会在其他模块中实现
5. 前端可以正确解析统一的响应格式

## 实现注意事项

- [ ] 确保 Result 类支持泛型，可以包装任意类型
- [ ] 确保所有类和方法添加中文注释
- [ ] 确保错误码常量符合项目规范
- [ ] 确保异常类可以正确序列化
- [ ] 确保分页对象计算逻辑正确
- [ ] 确保常量类不能被实例化
- [ ] 遵循包名规范：`com.atlas.common.feature.core`

